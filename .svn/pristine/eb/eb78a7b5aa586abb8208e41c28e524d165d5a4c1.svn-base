/**************************************************************************
 Requestor : Tan Pei Cheng
 Desc : Aggregate exposure
 Date : 11 August 2008
*************************************************************************/
DROP TABLE TEMP_FAC_SEC_ALLOC
@

CREATE TABLE TEMP_FAC_SEC_ALLOC (
--ID 				INT,     -- for debug purpose
CHARGE_ID 		BIGINT, 
LMT_ID 			BIGINT, 
COL_ID 			BIGINT, 
FAC_AMT 		DECIMAL(30,12), 
COL_AMT 		DECIMAL(30,12), 
OMV_AMT 		DECIMAL(30,12), 
FSV_AMT 		DECIMAL(30,12), 
ALLOC_AMT 		DECIMAL(30,12),
OMV_ALLOC_AMT 	DECIMAL(30,12),
FSV_ALLOC_AMT 	DECIMAL(30,12),
SURPLUS      	DECIMAL(30,12)
,LOG     		VARCHAR(2555)   -- for debug purpose
)in CMS_SMALL_DATA INDEX IN CMS_INDEX
@

CREATE INDEX TEMP_FAC_SEC_ALLOC_IDX1 ON TEMP_FAC_SEC_ALLOC
(LMT_ID ASC)@

CREATE INDEX TEMP_FAC_SEC_ALLOC_IDX2 ON TEMP_FAC_SEC_ALLOC
(CHARGE_ID ASC)@

CREATE INDEX TEMP_FAC_SEC_ALLOC_IDX3 ON TEMP_FAC_SEC_ALLOC
(COL_ID ASC)@

--DROP TABLE CMS_LIMIT_SEC_ALLOC
--@

--CREATE TABLE CMS_LIMIT_SEC_ALLOC (
--LMT_ID 			VARCHAR(43)
--)in CMS_SMALL_DATA INDEX IN CMS_INDEX
--@

--CREATE INDEX CMS_LIMIT_SEC_ALLOC_IDX1 ON CMS_LIMIT_SEC_ALLOC
--(LMT_ID ASC)
--@

DROP TABLE CMS_PROCESS_COL_ALLOC
@

CREATE TABLE CMS_PROCESS_COL_ALLOC (
COLL_ID 			BIGINT,
ALLOC_TYPE 			VARCHAR(1)
)in CMS_SMALL_DATA INDEX IN CMS_INDEX
@

CREATE INDEX CMS_PROCESS_COL_ALLOC_IDX1 ON CMS_PROCESS_COL_ALLOC
(COLL_ID ASC)
@
-----------------------------------
---Functions needed 
------------------------------------
DROP FUNCTION calcApportionAmt@

CREATE FUNCTION calcApportionAmt(lmtAmt DECIMAL(30,12), colAmt DECIMAL(30,12), totalLmt DECIMAL(30,12)) RETURNS DECIMAL(30,12) LANGUAGE SQL
BEGIN ATOMIC
 
  DECLARE result DECIMAL(30,12) DEFAULT 0;
  
  IF totalLmt IS NOT NULL AND totalLmt <> 0  THEN
    SET result = round( dec(lmtAmt)/dec(totalLmt), 16 ) * dec(colAmt,20,2);
  END IF;
   
  RETURN result;
END@

DROP FUNCTION getLowestAmt@

CREATE FUNCTION getLowestAmt(amt1 DECIMAL(30,12), amt2 DECIMAL(30,12), amt3 DECIMAL(30,12)) RETURNS DECIMAL(30,12) LANGUAGE SQL
BEGIN ATOMIC
 
  DECLARE lowestAmt DECIMAL(30,12) DEFAULT 0;
  SET lowestAmt = amt1;
  
  IF amt2 IS NOT NULL AND amt2 <> 0 AND amt2 < lowestAmt THEN
    SET lowestAmt = amt2;
  END IF;
  
  IF amt3 IS NOT NULL AND amt3 <> 0 AND amt3 < lowestAmt THEN
    SET lowestAmt = amt3;  
  END IF;
  RETURN lowestAmt;
END@

-----------------------------------
---Sub Procedures needed 
------------------------------------
DROP PROCEDURE PERSIST_COL_ALLOCATION@

CREATE PROCEDURE PERSIST_COL_ALLOCATION LANGUAGE SQL
BEGIN
    
DECLARE PREV_LMT_ID			BIGINT;
DECLARE TOTAL_OMV_ALLOC		DECIMAL(30,12) DEFAULT 0;
DECLARE TOTAL_FSV_ALLOC		DECIMAL(30,12) DEFAULT 0;
DECLARE TOTAL_ALLOC			DECIMAL(30,12) DEFAULT 0;
DECLARE CURR_ALLOC			DECIMAL(30,12) DEFAULT 0;
DECLARE CURR_OMV_ALLOC		DECIMAL(30,12) DEFAULT 0;
DECLARE CURR_FSV_ALLOC		DECIMAL(30,12) DEFAULT 0;
	
		
	INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID) (
		SELECT DISTINCT COL_ID FROM TEMP_FAC_SEC_ALLOC
	);	
	FOR cur1 AS
		SELECT CHARGE_ID, LMT_ID, COL_AMT, OMV_AMT, FSV_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT FROM TEMP_FAC_SEC_ALLOC ORDER BY LMT_ID 
	DO		
		
		IF ALLOC_AMT IS NULL THEN
			UPDATE CMS_LIMIT_SECURITY_MAP SET CMS_SEC_ALLOCATED_AMT = COALESCE( CMS_SEC_ALLOCATED_AMT, 0 ) + cur1.COL_AMT
			WHERE CHARGE_ID = cur1.CHARGE_ID;
			
			SET CURR_ALLOC =cur1.COL_AMT;
			SET CURR_OMV_ALLOC =cur1.OMV_AMT;
			SET CURR_FSV_ALLOC =cur1.FSV_AMT;
		ELSE
			UPDATE CMS_LIMIT_SECURITY_MAP SET CMS_SEC_ALLOCATED_AMT = COALESCE( CMS_SEC_ALLOCATED_AMT, 0 ) + cur1.ALLOC_AMT		
			WHERE CHARGE_ID = cur1.CHARGE_ID;
			
			SET CURR_ALLOC =cur1.ALLOC_AMT;
			SET CURR_OMV_ALLOC =cur1.OMV_ALLOC_AMT;
			SET CURR_FSV_ALLOC =cur1.FSV_ALLOC_AMT;
		END IF;
			
		IF PREV_LMT_ID IS NOT NULL AND PREV_LMT_ID <> cur1.LMT_ID THEN
	      		
			UPDATE SCI_LSP_APPR_LMTS SET 
				CMS_ACTUAL_SEC_COVERAGE_AMT = COALESCE( CMS_ACTUAL_SEC_COVERAGE_AMT, 0 ) + TOTAL_ALLOC, 
				CMS_OMV_SEC_COVERAGE_AMT = COALESCE( CMS_OMV_SEC_COVERAGE_AMT, 0 ) + TOTAL_OMV_ALLOC,
				CMS_FSV_SEC_COVERAGE_AMT = COALESCE( CMS_FSV_SEC_COVERAGE_AMT, 0 ) + TOTAL_FSV_ALLOC 
				WHERE CMS_LSP_APPR_LMTS_ID = PREV_LMT_ID;
			
			--UPDATE TEMP_FAC_SEC_ALLOC SET 
			--    	 LOG = CHAR(PREV_LMT_ID) || '-' || CHAR(TOTAL_ALLOC)
			--		WHERE LMT_ID = PREV_LMT_ID;
					
			SET TOTAL_ALLOC = 0;
			SET TOTAL_OMV_ALLOC = 0;
			SET TOTAL_FSV_ALLOC = 0;
			
		END IF ;			
							
		SET PREV_LMT_ID = cur1.LMT_ID;  
		SET TOTAL_ALLOC = TOTAL_ALLOC + CURR_ALLOC;  
		SET TOTAL_OMV_ALLOC = TOTAL_OMV_ALLOC + CURR_OMV_ALLOC;  
		SET TOTAL_FSV_ALLOC = TOTAL_FSV_ALLOC + CURR_FSV_ALLOC;  
					
	END FOR;
	
	UPDATE SCI_LSP_APPR_LMTS SET 
				CMS_ACTUAL_SEC_COVERAGE_AMT = COALESCE( CMS_ACTUAL_SEC_COVERAGE_AMT, 0 ) + TOTAL_ALLOC, 
				CMS_OMV_SEC_COVERAGE_AMT = COALESCE( CMS_OMV_SEC_COVERAGE_AMT, 0 ) + TOTAL_OMV_ALLOC,
				CMS_FSV_SEC_COVERAGE_AMT = COALESCE( CMS_FSV_SEC_COVERAGE_AMT, 0 ) + TOTAL_FSV_ALLOC 
				WHERE CMS_LSP_APPR_LMTS_ID = PREV_LMT_ID;
			
	--UPDATE TEMP_FAC_SEC_ALLOC SET 
	--		 LOG =CHAR(PREV_LMT_ID) || '-' || CHAR(TOTAL_ALLOC)
	--		WHERE LMT_ID = PREV_LMT_ID;
		
END@


DROP PROCEDURE PROC_CLEAR_PREV_ALLOC@

CREATE PROCEDURE PROC_CLEAR_PREV_ALLOC LANGUAGE SQL
BEGIN
  UPDATE CMS_LIMIT_SECURITY_MAP SET CMS_SEC_ALLOCATED_AMT = NULL WHERE CMS_SEC_ALLOCATED_AMT IS NOT NULL;
  commit;
  
  UPDATE SCI_LSP_APPR_LMTS SET CMS_ACTUAL_SEC_COVERAGE_AMT = NULL, CMS_OMV_SEC_COVERAGE_AMT = NULL, CMS_FSV_SEC_COVERAGE_AMT = NULL
  WHERE 
  CMS_ACTUAL_SEC_COVERAGE_AMT IS NOT NULL OR
  CMS_OMV_SEC_COVERAGE_AMT IS NOT NULL OR
  CMS_FSV_SEC_COVERAGE_AMT IS NOT NULL;
  commit;  
 
END@

DROP PROCEDURE COMPUTE_SHARED_COLL@

--CREATE PROCEDURE COMPUTE_SHARED_COLL( V_ID INT ) LANGUAGE SQL  -- FOR DEBUG

CREATE PROCEDURE COMPUTE_SHARED_COLL LANGUAGE SQL
BEGIN
DECLARE TOTAL_LMT_AMT			DECIMAL(30,12);
DECLARE APPORT_AMT				DECIMAL(30,12);
DECLARE OMV_APPORT_AMT			DECIMAL(30,12);
DECLARE FSV_APPORT_AMT			DECIMAL(30,12);

DECLARE PREV_CHARGE_ID			BIGINT;
DECLARE PREV_LMT_ID				BIGINT;
DECLARE PREV_LMT_AMT			DECIMAL(30,12);
DECLARE NET_EXP					DECIMAL(30,12);
DECLARE CURR_ALLOC_AMT			DECIMAL(30,12);
DECLARE CURR_COL_AMT			DECIMAL(30,12);
DECLARE TOTAL_COL_VAL			DECIMAL(30,12);
DECLARE TOTAL_RES_COL_VAL		DECIMAL(30,12) DEFAULT 1;
DECLARE TOTAL_ALLOC				DECIMAL(30,12);
DECLARE CURR_ALLOC				DECIMAL(30,12);
DECLARE OMV_DIFF			SMALLINT DEFAULT 1;
DECLARE IS_FIRST_TIME			SMALLINT DEFAULT 1;
DECLARE ALLOC_TYPE				SMALLINT DEFAULT 1;  -- first by actual apportion amt, second based on OMV, third based on FSV
DECLARE ITER					SMALLINT DEFAULT 1;  -- for debug

		
	--CALL UTIL_TRUNCATE_TABLE('TEMP_FAC_SEC_ALLOC');
	--UPDATE TEMP_FAC_SEC_ALLOC SET SURPLUS =NULL,ALLOC_AMT=NULL,OMV_ALLOC_AMT=NULL,FSV_ALLOC_AMT=NULL;
	
	WHILE ALLOC_TYPE < 4 
	DO	
	
		IF ALLOC_TYPE=2 THEN
			
			

				SET OMV_DIFF = ( SELECT count(1) FROM TEMP_FAC_SEC_ALLOC
										where COL_AMT <>  OMV_AMT
									);
				IF OMV_DIFF = 0 THEN
					UPDATE TEMP_FAC_SEC_ALLOC SET 			
						OMV_ALLOC_AMT = ALLOC_AMT			
						;
					set TOTAL_RES_COL_VAL=0;
				END IF;
					
			
								
					
					
		ELSEIF ALLOC_TYPE=3 THEN
					
				SET OMV_DIFF = ( SELECT count(1) FROM TEMP_FAC_SEC_ALLOC
										where COL_AMT <>  FSV_AMT
									);
				IF OMV_DIFF = 0 THEN
					UPDATE TEMP_FAC_SEC_ALLOC SET 			
						FSV_ALLOC_AMT = ALLOC_AMT			
						;
					set TOTAL_RES_COL_VAL=0;
				END IF;
					
		END IF;
		
		
		
		UPDATE TEMP_FAC_SEC_ALLOC SET SURPLUS = NULL;

		SET TOTAL_LMT_AMT = 0;
		
		WHILE TOTAL_RES_COL_VAL <> 0 --AND ITER <3
		DO		
		
			IF IS_FIRST_TIME=1 THEN 		
		
				FOR cur1 AS		
							
					SELECT CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT FROM TEMP_FAC_SEC_ALLOC WHERE COL_ID IN (
						SELECT COL_ID FROM TEMP_FAC_SEC_ALLOC GROUP BY COL_ID HAVING COUNT(*) >1 )						
					--AND ID = V_ID
				DO				
														
					
					
					SET TOTAL_LMT_AMT = 0;
					
					
					
					
					FOR cur_inner1 AS
						SELECT DISTINCT LMT_ID, FAC_AMT  FROM TEMP_FAC_SEC_ALLOC WHERE COL_ID = cur1.COL_ID
					DO
						SET TOTAL_LMT_AMT = TOTAL_LMT_AMT + cur_inner1.FAC_AMT ;
					
					END FOR;
					
					 

					
						
					IF ALLOC_TYPE=1 THEN
						SET APPORT_AMT = calcApportionAmt( cur1.FAC_AMT, cur1.COL_AMT, TOTAL_LMT_AMT );
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						ALLOC_AMT = APPORT_AMT 
						WHERE CHARGE_ID = cur1.CHARGE_ID;
						
						--UPDATE TEMP_FAC_SEC_ALLOC SET 
						--ALLOC_AMT = APPORT_AMT 
						--LOG = char(APPORT_AMT) 
						--WHERE CHARGE_ID = cur1.CHARGE_ID;
						
					ELSEIF ALLOC_TYPE=2 THEN
						SET OMV_APPORT_AMT = calcApportionAmt( cur1.FAC_AMT, cur1.OMV_AMT, TOTAL_LMT_AMT );
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 			
						OMV_ALLOC_AMT = OMV_APPORT_AMT			
						WHERE CHARGE_ID = cur1.CHARGE_ID;
						
					ELSEIF ALLOC_TYPE=3 THEN
						SET FSV_APPORT_AMT = calcApportionAmt( cur1.FAC_AMT, cur1.FSV_AMT, TOTAL_LMT_AMT );
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						FSV_ALLOC_AMT = FSV_APPORT_AMT 
						WHERE CHARGE_ID = cur1.CHARGE_ID;
					
					END IF;
										
					
				END FOR;	
				SET IS_FIRST_TIME=0;
				SET TOTAL_RES_COL_VAL=0;
			
			ELSE	
				
				SET TOTAL_LMT_AMT = 0;
				FOR CUR2 AS
					SELECT DISTINCT LMT_ID , FAC_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT, CHARGE_ID 
					FROM TEMP_FAC_SEC_ALLOC WHERE LMT_ID NOT IN (
					SELECT DISTINCT LMT_ID FROM TEMP_FAC_SEC_ALLOC  WHERE  SURPLUS IS NOT NULL )					
					--AND ID = V_ID
				DO		
					--SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + CUR5.FAC_AMT ;
					
					
					IF ALLOC_TYPE=1 THEN
						IF CUR2.ALLOC_AMT IS NOT NULL THEN
						
						SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + CUR2.FAC_AMT ;
					
						END IF;
						
					ELSEIF ALLOC_TYPE=2 THEN
						
						IF CUR2.OMV_ALLOC_AMT IS NOT NULL THEN
						
						SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + CUR2.FAC_AMT ;
					
						END IF;
						
					ELSEIF ALLOC_TYPE=3 THEN
					
						IF CUR2.FSV_ALLOC_AMT IS NOT NULL THEN
						
						SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + CUR2.FAC_AMT ;
					
						END IF;
					
					END IF;
				
					
						
				END FOR; -- end cur2

				FOR CUR3 AS
					SELECT DISTINCT LMT_ID , FAC_AMT, CHARGE_ID FROM TEMP_FAC_SEC_ALLOC WHERE LMT_ID NOT IN (
					SELECT DISTINCT LMT_ID FROM TEMP_FAC_SEC_ALLOC  WHERE  SURPLUS IS NOT NULL ) 					
					--AND ID = V_ID
				DO	
					SET APPORT_AMT = calcApportionAmt( CUR3.FAC_AMT, TOTAL_RES_COL_VAL, TOTAL_LMT_AMT );											
					
					IF ALLOC_TYPE=1 THEN					
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						ALLOC_AMT = ALLOC_AMT+APPORT_AMT 			
						WHERE CHARGE_ID = CUR3.CHARGE_ID;				
												
						
					ELSEIF ALLOC_TYPE=2 THEN
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 				
						OMV_ALLOC_AMT = OMV_ALLOC_AMT+APPORT_AMT				
						WHERE CHARGE_ID = CUR3.CHARGE_ID;
						
					ELSEIF ALLOC_TYPE=3 THEN
					
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						FSV_ALLOC_AMT = FSV_ALLOC_AMT+APPORT_AMT 			
						WHERE CHARGE_ID = CUR3.CHARGE_ID;
					
					END IF;
													
				END FOR; -- end cur3
				
				FOR CUR4 AS
					SELECT DISTINCT LMT_ID, FAC_AMT, CHARGE_ID, SURPLUS FROM TEMP_FAC_SEC_ALLOC WHERE LMT_ID IN (
					SELECT DISTINCT LMT_ID FROM TEMP_FAC_SEC_ALLOC  WHERE  SURPLUS IS NOT NULL ) 
					--AND ID = V_ID
				DO							
					
					IF ALLOC_TYPE=1 THEN					
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						ALLOC_AMT = ALLOC_AMT - SURPLUS,
						SURPLUS = 0			
						WHERE CHARGE_ID = CUR4.CHARGE_ID;				
						
												
					ELSEIF ALLOC_TYPE=2 THEN
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 			
						OMV_ALLOC_AMT = OMV_ALLOC_AMT - SURPLUS,  			
						SURPLUS = 0			
						WHERE CHARGE_ID = CUR4.CHARGE_ID;
					
					ELSEIF ALLOC_TYPE=3 THEN				
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 			
						FSV_ALLOC_AMT = FSV_ALLOC_AMT - SURPLUS,
						SURPLUS = 0			
						WHERE CHARGE_ID = CUR4.CHARGE_ID;
					
					END IF;
					
				END FOR; -- end cur4		
		
			END IF;
		
			SET NET_EXP = 0;
			SET CURR_ALLOC_AMT = NULL;
			SET CURR_COL_AMT = NULL;
			
			FOR CUR5 AS
				SELECT CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT 
				FROM TEMP_FAC_SEC_ALLOC 
				--WHERE ID = V_ID
				ORDER BY LMT_ID 
			DO		
				
				IF PREV_LMT_ID IS NOT NULL AND PREV_LMT_ID <> CUR5.LMT_ID THEN
			      
				  SET NET_EXP = PREV_LMT_AMT - TOTAL_COL_VAL;
				  
						
				    IF NET_EXP > 0  THEN
						UPDATE TEMP_FAC_SEC_ALLOC SET 
								SURPLUS = (NET_EXP) 
								WHERE CHARGE_ID = PREV_CHARGE_ID;
								
						
						
					END IF;
					SET TOTAL_COL_VAL = 0;
					SET NET_EXP = 0;
				END IF ;
					
				IF ALLOC_TYPE=1 THEN
											
					SET CURR_ALLOC_AMT = CUR5.ALLOC_AMT;
					SET CURR_COL_AMT = CUR5.COL_AMT;
										
				ELSEIF ALLOC_TYPE=2 THEN
					
					SET CURR_ALLOC_AMT = CUR5.OMV_ALLOC_AMT;
					SET CURR_COL_AMT = CUR5.OMV_AMT;

				ELSEIF ALLOC_TYPE=3 THEN			
					
					SET CURR_ALLOC_AMT = CUR5.FSV_ALLOC_AMT;
					SET CURR_COL_AMT = CUR5.FSV_AMT;

				END IF;
									
				IF CURR_ALLOC_AMT IS NULL  THEN
					 SET TOTAL_COL_VAL = TOTAL_COL_VAL + CURR_COL_AMT;
				  ELSE
					SET TOTAL_COL_VAL = TOTAL_COL_VAL + CURR_ALLOC_AMT;
			    END IF;  
			    

				SET PREV_CHARGE_ID = CUR5.CHARGE_ID;
			    SET PREV_LMT_ID = CUR5.LMT_ID;
				SET PREV_LMT_AMT = CUR5.FAC_AMT;
				   				
						
			END FOR; -- end CUR5
								  
			SET TOTAL_RES_COL_VAL = ( SELECT count(1) FROM TEMP_FAC_SEC_ALLOC 
										where SURPLUS < 0
									);
			IF TOTAL_RES_COL_VAL <> 0 THEN
				SET TOTAL_RES_COL_VAL = ( SELECT SUM(SURPLUS) FROM TEMP_FAC_SEC_ALLOC where surplus is not null 
											--WHERE ID = V_ID
										);
			END IF;
						
			--SET ITER = ITER + 1;
			END WHILE;
			
		SET ALLOC_TYPE = ALLOC_TYPE + 1;
		SET IS_FIRST_TIME = 1;
		SET TOTAL_RES_COL_VAL = 1;
		--SET ITER =1;
	END WHILE;
		
END@

DROP PROCEDURE COMPUTE_SHARED_COLL2@

CREATE PROCEDURE COMPUTE_SHARED_COLL2 LANGUAGE SQL
BEGIN
DECLARE TOTAL_LMT_AMT			DECIMAL(30,12);
DECLARE APPORT_AMT				DECIMAL(30,12);
DECLARE OMV_APPORT_AMT			DECIMAL(30,12);
DECLARE FSV_APPORT_AMT			DECIMAL(30,12);

DECLARE PREV_CHARGE_ID			BIGINT;
DECLARE PREV_LMT_ID				BIGINT;
DECLARE PREV_LMT_AMT			DECIMAL(30,12);
DECLARE NET_EXP					DECIMAL(30,12);
DECLARE CURR_ALLOC_AMT			DECIMAL(30,12);
DECLARE CURR_COL_AMT			DECIMAL(30,12);
DECLARE TOTAL_COL_VAL			DECIMAL(30,12);
DECLARE TOTAL_RES_COL_VAL		DECIMAL(30,12) DEFAULT 1;
DECLARE TOTAL_ALLOC				DECIMAL(30,12);
DECLARE CURR_ALLOC				DECIMAL(30,12);
DECLARE IS_FIRST_TIME			SMALLINT DEFAULT 1;
DECLARE ALLOC_TYPE				SMALLINT DEFAULT 1;  -- first by actual apportion amt, second based on OMV, third based on FSV
--DECLARE ITER					SMALLINT DEFAULT 1;  -- for debug

DECLARE COL_ID			BIGINT;
DECLARE LMT_ID			BIGINT;
DECLARE CHARGE_ID		BIGINT;
DECLARE FAC_AMT			DECIMAL(30,12);
DECLARE COL_AMT			DECIMAL(30,12);
DECLARE OMV_AMT			DECIMAL(30,12);
DECLARE FSV_AMT			DECIMAL(30,12);

DECLARE ALLOC_AMT			DECIMAL(30,12);
DECLARE OMV_ALLOC_AMT		DECIMAL(30,12);
DECLARE FSV_ALLOC_AMT		DECIMAL(30,12);
DECLARE SURPLUS				DECIMAL(30,12);

DECLARE IS_OMV_DIFF			SMALLINT DEFAULT 1;
DECLARE IS_FSV_DIFF			SMALLINT DEFAULT 1;

DECLARE v_no_data SMALLINT DEFAULT 0;

DECLARE cur1 CURSOR FOR 
  		SELECT CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT FROM TEMP_FAC_SEC_ALLOC WHERE COL_ID IN (
						SELECT COL_ID FROM TEMP_FAC_SEC_ALLOC GROUP BY COL_ID HAVING COUNT(*) >1 );

DECLARE cur2 CURSOR FOR 
  		SELECT DISTINCT LMT_ID , FAC_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT, CHARGE_ID 
					FROM TEMP_FAC_SEC_ALLOC WHERE LMT_ID NOT IN (
					SELECT DISTINCT LMT_ID FROM TEMP_FAC_SEC_ALLOC  WHERE  SURPLUS IS NOT NULL );
					
DECLARE cur3 CURSOR FOR 			
		SELECT DISTINCT LMT_ID , FAC_AMT, CHARGE_ID FROM TEMP_FAC_SEC_ALLOC WHERE LMT_ID NOT IN (
					SELECT DISTINCT LMT_ID FROM TEMP_FAC_SEC_ALLOC  WHERE  SURPLUS IS NOT NULL ); 

DECLARE cur4 CURSOR FOR 	
SELECT DISTINCT LMT_ID, FAC_AMT, CHARGE_ID, SURPLUS FROM TEMP_FAC_SEC_ALLOC WHERE LMT_ID IN (
					SELECT DISTINCT LMT_ID FROM TEMP_FAC_SEC_ALLOC  WHERE  SURPLUS IS NOT NULL );

DECLARE cur5 CURSOR FOR 	
SELECT CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT 
				FROM TEMP_FAC_SEC_ALLOC 				
				ORDER BY LMT_ID; 
				
	DECLARE CONTINUE HANDLER FOR NOT FOUND
		SET v_no_data = 1;
				
	--CALL UTIL_TRUNCATE_TABLE('TEMP_FAC_SEC_ALLOC');
	--UPDATE TEMP_FAC_SEC_ALLOC SET SURPLUS =NULL,ALLOC_AMT=NULL,OMV_ALLOC_AMT=NULL,FSV_ALLOC_AMT=NULL;
		
	WHILE ALLOC_TYPE < 4 
	DO					
		-- IF OMV = col amt, no need to recalculate again
		IF ALLOC_TYPE=2 THEN
						
				SET IS_OMV_DIFF = ( SELECT count(1) FROM TEMP_FAC_SEC_ALLOC
										where COL_AMT <>  OMV_AMT
									);
				IF IS_OMV_DIFF = 0 THEN
					UPDATE TEMP_FAC_SEC_ALLOC SET 			
						OMV_ALLOC_AMT = ALLOC_AMT;
					SET TOTAL_RES_COL_VAL=0;
				END IF;																
		
		-- IF FSV = col amt, no need to recalculate again		
		ELSEIF ALLOC_TYPE=3 THEN
					
				SET IS_FSV_DIFF = ( SELECT count(1) FROM TEMP_FAC_SEC_ALLOC
										where COL_AMT <>  FSV_AMT
									);
				IF IS_FSV_DIFF = 0 THEN
					UPDATE TEMP_FAC_SEC_ALLOC SET 			
						FSV_ALLOC_AMT = ALLOC_AMT;
					SET TOTAL_RES_COL_VAL=0;
				END IF;
					
		END IF;		
		
		UPDATE TEMP_FAC_SEC_ALLOC SET SURPLUS = NULL;

		SET TOTAL_LMT_AMT = 0;
		
		WHILE TOTAL_RES_COL_VAL <> 0 --AND ITER < 3
		DO		
		
			IF IS_FIRST_TIME=1 THEN 		
		
				SET v_no_data = 0;
				
				OPEN cur1;

				FETCH cur1 INTO CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT;
					
				WHILE (v_no_data = 0) DO	
											
					SET TOTAL_LMT_AMT = 0;
					
					FOR cur_inner1 AS
						SELECT DISTINCT LMT_ID, FAC_AMT  FROM TEMP_FAC_SEC_ALLOC WHERE COL_ID = COL_ID
					DO
						SET TOTAL_LMT_AMT = TOTAL_LMT_AMT + cur_inner1.FAC_AMT ;
					
					END FOR;
					
					IF ALLOC_TYPE=1 THEN
						SET APPORT_AMT = calcApportionAmt( FAC_AMT, COL_AMT, TOTAL_LMT_AMT );
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						ALLOC_AMT = APPORT_AMT 
						WHERE CHARGE_ID = CHARGE_ID;
						
					ELSEIF ALLOC_TYPE=2 THEN
						SET OMV_APPORT_AMT = calcApportionAmt( FAC_AMT, OMV_AMT, TOTAL_LMT_AMT );
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 			
						OMV_ALLOC_AMT = OMV_APPORT_AMT			
						WHERE CHARGE_ID = CHARGE_ID;
						
					ELSEIF ALLOC_TYPE=3 THEN
						SET FSV_APPORT_AMT = calcApportionAmt( FAC_AMT, FSV_AMT, TOTAL_LMT_AMT );
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						FSV_ALLOC_AMT = FSV_APPORT_AMT 
						WHERE CHARGE_ID = CHARGE_ID;
					
					END IF;
					
					SET v_no_data = 0;  
					FETCH cur1 INTO CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT;
					
				END WHILE;
				CLOSE cur1;	
				
				SET IS_FIRST_TIME=0;
				SET TOTAL_RES_COL_VAL=0;
			
			ELSE	
				
				SET TOTAL_LMT_AMT = 0;
					
				--SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + CUR5.FAC_AMT ;
				
				SET v_no_data = 0;
			
				OPEN cur2;

				FETCH cur2 INTO LMT_ID , FAC_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT, CHARGE_ID;
					
				WHILE (v_no_data = 0) DO	

					IF ALLOC_TYPE=1 THEN
						IF ALLOC_AMT IS NOT NULL THEN
						
						SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + FAC_AMT ;
					
						END IF;
						
					ELSEIF ALLOC_TYPE=2 THEN
						
						IF OMV_ALLOC_AMT IS NOT NULL THEN
						
						SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + FAC_AMT ;
					
						END IF;
						
					ELSEIF ALLOC_TYPE=3 THEN
					
						IF FSV_ALLOC_AMT IS NOT NULL THEN
						
						SET TOTAL_LMT_AMT= TOTAL_LMT_AMT + FAC_AMT ;
					
						END IF;
					
					END IF;			
										
					SET v_no_data = 0;  
					FETCH cur2 INTO LMT_ID , FAC_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT, CHARGE_ID;
					
				END WHILE;
				CLOSE cur2;
				
													
				--END FOR; -- end cur2
				SET v_no_data = 0;
			
				OPEN CUR3;

				FETCH CUR3 INTO LMT_ID, FAC_AMT, CHARGE_ID;
					
				WHILE (v_no_data = 0) DO	
											
					SET APPORT_AMT = calcApportionAmt( FAC_AMT, TOTAL_RES_COL_VAL, TOTAL_LMT_AMT );											
					
					IF ALLOC_TYPE=1 THEN					
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						ALLOC_AMT = ALLOC_AMT+APPORT_AMT 			
						WHERE CHARGE_ID = CHARGE_ID;				
						
					ELSEIF ALLOC_TYPE=2 THEN
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 				
						OMV_ALLOC_AMT = OMV_ALLOC_AMT+APPORT_AMT				
						WHERE CHARGE_ID = CHARGE_ID;
						
					ELSEIF ALLOC_TYPE=3 THEN
					
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						FSV_ALLOC_AMT = FSV_ALLOC_AMT+APPORT_AMT 			
						WHERE CHARGE_ID = CHARGE_ID;
					
					END IF;
						
						SET v_no_data = 0;  
						FETCH CUR3 INTO LMT_ID , FAC_AMT, CHARGE_ID;
						
				END WHILE;
				CLOSE CUR3;
																						
				--END FOR; -- end cur3
							
				SET v_no_data = 0;
				
				OPEN CUR4;

				FETCH CUR4 INTO LMT_ID, FAC_AMT, CHARGE_ID, SURPLUS;
					
				WHILE (v_no_data = 0) DO	
											
					IF ALLOC_TYPE=1 THEN					
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 
						ALLOC_AMT = ALLOC_AMT - SURPLUS,
						SURPLUS = 0			
						WHERE CHARGE_ID = CHARGE_ID;				
						
					ELSEIF ALLOC_TYPE=2 THEN
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 			
						OMV_ALLOC_AMT = OMV_ALLOC_AMT - SURPLUS,  			
						SURPLUS = 0			
						WHERE CHARGE_ID = CHARGE_ID;
					
					ELSEIF ALLOC_TYPE=3 THEN				
						
						UPDATE TEMP_FAC_SEC_ALLOC SET 			
						FSV_ALLOC_AMT = FSV_ALLOC_AMT - SURPLUS,
						SURPLUS = 0			
						WHERE CHARGE_ID = CHARGE_ID;
					
					END IF;
					
					SET v_no_data = 0;  
					FETCH CUR4 INTO LMT_ID, FAC_AMT, CHARGE_ID, SURPLUS;
					
				END WHILE;
				CLOSE CUR4;														
					
				--END FOR; -- end cur4		
		
			END IF;
		
			SET NET_EXP = 0;
			SET CURR_ALLOC_AMT = NULL;
			SET CURR_COL_AMT = NULL;
										
			SET v_no_data = 0;
			
			OPEN CUR5;

			FETCH CUR5 INTO CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT;
				
			WHILE (v_no_data = 0) DO	

				IF PREV_LMT_ID IS NOT NULL AND PREV_LMT_ID <> LMT_ID THEN
			      
				  SET NET_EXP = PREV_LMT_AMT - TOTAL_COL_VAL;
				  IF NET_EXP < 0  THEN
					UPDATE TEMP_FAC_SEC_ALLOC SET 
							SURPLUS = -(NET_EXP) 
							WHERE CHARGE_ID = PREV_CHARGE_ID;
					END IF;
					SET TOTAL_COL_VAL = 0;
					SET NET_EXP = 0;
				END IF ;
					
				IF ALLOC_TYPE=1 THEN
											
					SET CURR_ALLOC_AMT = ALLOC_AMT;
					SET CURR_COL_AMT = COL_AMT;
										
				ELSEIF ALLOC_TYPE=2 THEN
					
					SET CURR_ALLOC_AMT = OMV_ALLOC_AMT;
					SET CURR_COL_AMT = OMV_AMT;

				ELSEIF ALLOC_TYPE=3 THEN			
					
					SET CURR_ALLOC_AMT = FSV_ALLOC_AMT;
					SET CURR_COL_AMT = FSV_AMT;

				END IF;
									
				IF CURR_ALLOC_AMT IS NULL  THEN
					 SET TOTAL_COL_VAL = TOTAL_COL_VAL + CURR_COL_AMT;
				  ELSE
					SET TOTAL_COL_VAL = TOTAL_COL_VAL + CURR_ALLOC_AMT;
			    END IF;  
			    
				SET PREV_CHARGE_ID = CHARGE_ID;
			    SET PREV_LMT_ID = LMT_ID;
				SET PREV_LMT_AMT = FAC_AMT;
					
				SET v_no_data = 0;  
				FETCH CUR5 INTO CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT, ALLOC_AMT, OMV_ALLOC_AMT, FSV_ALLOC_AMT;
					
				END WHILE;
				CLOSE CUR5;
											   										
			--END FOR; -- end CUR5			
			
			SET TOTAL_RES_COL_VAL = ( SELECT count(1) FROM TEMP_FAC_SEC_ALLOC
										where SURPLUS < 0
									);
			IF TOTAL_RES_COL_VAL <> 0 THEN
				SET TOTAL_RES_COL_VAL = ( SELECT SUM(SURPLUS) FROM TEMP_FAC_SEC_ALLOC where surplus is not null 
											--WHERE ID = V_ID
										);
			END IF;
			
		--SET ITER = ITER + 1;
		END WHILE;
		
		SET ALLOC_TYPE = ALLOC_TYPE + 1;
		
		SET IS_FIRST_TIME = 1;
		SET TOTAL_RES_COL_VAL = 1;
		--SET ITER =1;
	END WHILE;
		
END@

DROP PROCEDURE GET_SHARED_COLL@

CREATE PROCEDURE GET_SHARED_COLL( P_COL_ID BIGINT, ID INT ) LANGUAGE SQL
BEGIN
DECLARE LOWEST_SEC_VAL	DECIMAL(30,12);
DECLARE COL_ID			BIGINT;
DECLARE LMT_ID			BIGINT;
DECLARE CHARGE_ID		BIGINT;
DECLARE CUST_ID			BIGINT;
DECLARE LMT_AMT			DECIMAL(30,12) DEFAULT 0;
DECLARE CMV				DECIMAL(30,12) DEFAULT 0;
DECLARE FSV				DECIMAL(30,12) DEFAULT 0;
DECLARE RV				DECIMAL(30,12) DEFAULT 0;
DECLARE RP				DECIMAL(30,12) DEFAULT 0;
DECLARE NPL_STATUS		CHAR(1);
DECLARE LMT_TYPE_VALUE	VARCHAR(10);
DECLARE v_tmp_cnt INT;
DECLARE is_npl_ind SMALLINT DEFAULT 0;

DECLARE v_shared_col_sql VARCHAR(2500);
DECLARE v_no_data SMALLINT DEFAULT 0;
DECLARE v_shared_col_stmt STATEMENT;

DECLARE cur1 CURSOR WITH HOLD FOR v_shared_col_stmt;
DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET v_no_data = 1;
	
	--DELETE FROM SESSION.FAC_SEC_ALLOC;
	delete from TEMP_FAC_SEC_ALLOC;
	--FOR cur1 AS
	SET v_shared_col_sql =	'SELECT M.CMS_COLLATERAL_ID COL_ID, L.CMS_LSP_APPR_LMTS_ID LMT_ID, ' ||
							'M.CHARGE_ID CHARGE_ID, p.CMS_CUSTOMER_ID CUST_ID, ' ||
							'L.LMT_TYPE_VALUE, ' ||
							'CONVERT_AMT( L.CMS_OUTSTANDING_AMT, L.LMT_CRRNCY_ISO_CODE, ''MYR'' ) LMT_AMT, ' ||		
							'CONVERT_AMT( S.CMV, S.CMV_CURRENCY, ''MYR'' ) CMV, ' ||
							'CONVERT_AMT( S.FSV, S.FSV_CURRENCY, ''MYR'' ) FSV, ' ||
							'CONVERT_AMT( S.NET_REALIZABLE_VALUE, S.SCI_SECURITY_CURRENCY, ''MYR'' ) RV, ' ||
							'CONVERT_AMT( S.RESERVE_PRICE, S.SCI_SECURITY_CURRENCY, ''MYR'' ) RP ' ||		
							--'( ' ||
							--'CASE WHEN ' ||
							--'SECURITY_SUB_TYPE_ID LIKE ''PT%'' OR ' ||
							--'SECURITY_SUB_TYPE_ID LIKE ''AB%'' OR ' ||
							--'SECURITY_SUB_TYPE_ID LIKE ''OT%'' ' || 
							--'THEN ( ' ||
							--	'SELECT CONVERT_AMT( V.RESERVE_PRICE , V.VALUATION_CURRENCY, ''MYR'' ) ' ||
							--	'FROM CMS_VALUATION V ' ||
							--	'WHERE V.CMS_COLLATERAL_ID = s.CMS_COLLATERAL_ID ' ||
							--	'		AND V.SOURCE_TYPE = ''M'' ' ||
							--	'		AND V.RESERVE_PRICE IS NOT NULL AND V.RESERVE_PRICE <> 0 ' ||
							--	'ORDER BY V.VALUATION_DATE DESC, V.VALUATION_ID DESC ' ||
							--	'FETCH FIRST 1 ROWS ONLY ' ||
							--' ) ' ||
							--'ELSE 0 ' ||
							--'END ' ||								
							--') RP ' ||							
							'FROM SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S , SCI_LSP_LMT_PROFILE p ' ||
							'WHERE p.CMS_CUSTOMER_ID IN ' ||
							'( ' ||
							'	SELECT CMS_CUSTOMER_ID ' ||
							'	FROM SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, SCI_LSP_LMT_PROFILE p  ' ||
							'	WHERE ' ||
							'		L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID ' ||
							'		AND M.CMS_COLLATERAL_ID = ? ' ||
							'		AND L.lmt_type_value = ''OUTER'' ' ||
							'		AND L.CMS_LIMIT_STATUS <> ''DELETED'' ' ||
							'		AND M.UPDATE_STATUS_IND <> ''D''	' ||		 
							'		AND l.CMS_LIMIT_PROFILE_ID = p.CMS_LSP_LMT_PROFILE_ID ' ||
							'		AND p.CMS_BCA_STATUS  <> ''DELETED''	' ||		
							') ' ||
							'AND L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID ' ||
					        'AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID ' || 	 
							'AND L.lmt_type_value = ''OUTER'' ' ||
							'AND L.CMS_LIMIT_STATUS <> ''DELETED'' ' ||
							'AND M.UPDATE_STATUS_IND <> ''D''	' ||		
							'AND l.CMS_LIMIT_PROFILE_ID = p.CMS_LSP_LMT_PROFILE_ID ' ||
							'AND p.CMS_BCA_STATUS  <> ''DELETED'' ' ||
							'AND ( S.CMV IS NOT NULL OR S.CMV <> 0 ) ' ||
							'AND S.SECURITY_SUB_TYPE_ID <> ''GT408'' ' ||  -- filter out individual guarantee subtype
							'ORDER BY CUST_ID, LMT_ID ';

	--DO 				
					
		SET v_no_data = 0;

		PREPARE v_shared_col_stmt FROM v_shared_col_sql;

		OPEN cur1 using P_COL_ID;

		FETCH cur1 INTO COL_ID, LMT_ID, CHARGE_ID, CUST_ID, LMT_TYPE_VALUE, LMT_AMT, CMV, 
			FSV, RV, RP;
			
		WHILE (v_no_data = 0) DO	
	
		-- CHECK WHETHER THIS COLLATERAL BEEN PROCESS BEFORE
			set v_tmp_cnt = (SELECT COUNT(1) FROM CMS_PROCESS_COL_ALLOC WHERE COLL_ID = COL_ID); 
				
			IF v_tmp_cnt = 0 THEN	
		
				SET is_npl_ind = (SELECT COUNT(1) FROM SESSION.NPL_ACCOUNT WHERE LIMIT_ID = LMT_ID); 
										
				-- performing loan
				IF is_npl_ind is NULL OR is_npl_ind = 0 THEN	     
				
					INSERT INTO TEMP_FAC_SEC_ALLOC( CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT )
						VALUES
						( CHARGE_ID, LMT_ID, COL_ID, LMT_AMT, CMV, CMV, FSV );
									
				ELSE					
				-- non performing loan
				
					SET LOWEST_SEC_VAL = getLowestAmt( FSV, RV, RP );   	   

					INSERT INTO TEMP_FAC_SEC_ALLOC( CHARGE_ID, LMT_ID, COL_ID, FAC_AMT, COL_AMT, OMV_AMT, FSV_AMT )
						VALUES
						( CHARGE_ID, LMT_ID, COL_ID, LMT_AMT, LOWEST_SEC_VAL, CMV, FSV );
											
				END IF;				
				
				--INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID) VALUES(COL_ID);	
				
				  
			
			END IF;
			
			SET v_no_data = 0;
			
			FETCH cur1 INTO COL_ID, LMT_ID, CHARGE_ID, CUST_ID, LMT_TYPE_VALUE, LMT_AMT, CMV, 
				FSV, RV, RP;
		END WHILE;
		CLOSE cur1;
						
	--END FOR;	
	
END@


-----------------------------------
---Main Procedure
------------------------------------

DROP PROCEDURE PROC_COLL_ALLOC_MAIN@

CREATE PROCEDURE PROC_COLL_ALLOC_MAIN LANGUAGE SQL
BEGIN
	 
DECLARE LOWEST_SEC_VAL	DECIMAL(30,12);
DECLARE v_tmp_cnt INT;
DECLARE main_cnt INT DEFAULT 0;
	 
DECLARE PREV_CUST_ID		BIGINT;
DECLARE PREV_LMT_ID			BIGINT;
DECLARE PREV_COL_ID			BIGINT;
DECLARE PREV_CHARGE_DTL_ID			BIGINT;
DECLARE PREV_CHARGE_AMT			DECIMAL(30,12);
DECLARE REMAIN_OMV			DECIMAL(30,12);
DECLARE REMAIN_FSV			DECIMAL(30,12);
DECLARE TOTAL_LMT_OUTSTANDING DECIMAL(30,12);
DECLARE APPORTIONMENT_EXP	DECIMAL(30,12);

DECLARE IS_PREV_SPECIFIC	SMALLINT DEFAULT 0;
DECLARE IS_FIRST			SMALLINT DEFAULT 1;

DECLARE v_no_data SMALLINT DEFAULT 0;
DECLARE is_npl_ind SMALLINT DEFAULT 0;

DECLARE NPL_LIMIT_ID		BIGINT;

DECLARE npl_cur CURSOR WITH HOLD FOR 
  		SELECT XM.CMS_LSP_APPR_LMTS_ID FROM SCI_LSP_LMTS_XREF_MAP XM, SCI_LSP_SYS_XREF X 
		WHERE 
		X.CMS_LSP_SYS_XREF_ID = XM.CMS_LSP_SYS_XREF_ID 
			--	AND XM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID 
			AND XM.CMS_STATUS = 'ACTIVE' 
			AND X.ACCT_DELQ_IND = 'Y';
			
DECLARE CONTINUE HANDLER FOR NOT FOUND
	SET v_no_data = 1;
		
DECLARE GLOBAL TEMPORARY TABLE SESSION.NPL_ACCOUNT(LIMIT_ID BIGINT) WITH REPLACE ON COMMIT PRESERVE ROWS NOT LOGGED;		 
	 
DECLARE GLOBAL TEMPORARY TABLE SESSION.PROCESS_COL(COLL_ID BIGINT,ALLOC_TYPE VARCHAR(1)) WITH REPLACE ON COMMIT PRESERVE ROWS NOT LOGGED;

DECLARE GLOBAL TEMPORARY TABLE SESSION.FAC_SEC_ALLOC(
CHARGE_ID 		BIGINT, 
LMT_ID 			BIGINT, 
COL_ID 			BIGINT, 
FAC_AMT 		DECIMAL(30,12), 
COL_AMT 		DECIMAL(30,12), 
OMV_AMT 		DECIMAL(30,12), 
FSV_AMT 		DECIMAL(30,12), 
ALLOC_AMT 		DECIMAL(30,12),
OMV_ALLOC_AMT 	DECIMAL(30,12),
FSV_ALLOC_AMT 	DECIMAL(30,12),
SURPLUS      	DECIMAL(30,12) ) WITH REPLACE ON COMMIT PRESERVE ROWS NOT LOGGED;
	CREATE INDEX SESSION.FAC_SEC_ALLOC_IDX1 ON SESSION.FAC_SEC_ALLOC(LMT_ID ASC) 
		ALLOW REVERSE SCANS;
	CREATE INDEX SESSION.FAC_SEC_ALLOC_IDX2 ON SESSION.FAC_SEC_ALLOC(CHARGE_ID ASC) 
		ALLOW REVERSE SCANS;
	CREATE INDEX SESSION.FAC_SEC_ALLOC_IDX3 ON SESSION.FAC_SEC_ALLOC(COL_ID ASC) 
		ALLOW REVERSE SCANS;
	
		
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 1);
	
	OPEN npl_cur;
  
	FETCH npl_cur INTO NPL_LIMIT_ID;
	WHILE (v_no_data = 0) DO
		INSERT INTO SESSION.NPL_ACCOUNT( LIMIT_ID ) VALUES( NPL_LIMIT_ID );	
			--INSERT INTO TEMP_FAC_SEC_ALLOC( CHARGE_ID, LMT_ID )
			--		VALUES
			--		( NPL_LIMIT_ID, NPL_LIMIT_ID );
	FETCH npl_cur INTO NPL_LIMIT_ID;
	END WHILE;
	CLOSE npl_cur;
	
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 100);
	
	DELETE FROM CMS_PROCESS_COL_ALLOC;
	-- Priority 1:  Property/Asset based multiple charge ranking = general	
	FOR cur0 AS		
		  
		  -- SELECT Property/Asset based with multiple charge ranking	
		  SELECT M.CMS_COLLATERAL_ID COL_ID, L.CMS_LSP_APPR_LMTS_ID LMT_ID, C.CHARGE_DETAIL_ID CHARGE_DTL_ID, 
			M.CHARGE_ID CHARGE_ID, P.CMS_CUSTOMER_ID CUST_ID,
			CONVERT_AMT( C.CHARGE_AMOUNT, C.CHARGE_CURRENCY_CODE, 'MYR' ) CHARGE_AMT, 
			CONVERT_AMT( S.CMV, S.CMV_CURRENCY, 'MYR' ) OMV, 			
			CONVERT_AMT( S.FSV, S.FSV_CURRENCY, 'MYR' ) FSV, 			
            C.SECURITY_RANK, C.PRIOR_CHARGE_TYPE, C.CHARGE_TYPE,
			L.CMS_OUTSTANDING_AMT
-- 			,
-- 			( 
-- 				select round( dec(l.CMS_OUTSTANDING_AMT,20,2)/ dec( sum( inner_l.CMS_OUTSTANDING_AMT ), 20, 2) , 16) 
-- 				from SCI_LSP_APPR_LMTS inner_l, CMS_LIMIT_SECURITY_MAP inner_M, CMS_LIMIT_CHARGE_MAP inner_cm, CMS_CHARGE_DETAIL inner_C 
-- 				where  
-- 				inner_CM.CMS_LSP_APPR_LMTS_ID = inner_L.CMS_LSP_APPR_LMTS_ID
-- 				AND inner_C.CHARGE_DETAIL_ID = inner_CM.CHARGE_DETAIL_ID 
-- 				AND inner_M.CHARGE_ID = inner_CM.CHARGE_ID 
-- 				and inner_cm.CHARGE_DETAIL_ID = c.CHARGE_DETAIL_ID
-- 				AND inner_L.lmt_type_value = 'OUTER'
-- 				AND inner_L.CMS_LIMIT_STATUS <> 'DELETED'
-- 				AND inner_M.UPDATE_STATUS_IND <> 'D'
-- 				AND inner_C.STATUS = 'ACTIVE'  
-- 				AND inner_CM.STATUS = 'ACTIVE'   
-- 			) Apport_Exp
			FROM SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, SCI_LSP_LMT_PROFILE p, CMS_LIMIT_CHARGE_MAP CM, CMS_CHARGE_DETAIL C 
			WHERE ( S.CMS_COLLATERAL_ID ) IN (
				SELECT CM.CMS_COLLATERAL_ID FROM 
					  SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, CMS_LIMIT_CHARGE_MAP CM, CMS_CHARGE_DETAIL C
					  WHERE 
					  L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
			          AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
					  AND L.LMT_TYPE_VALUE = 'OUTER'
					  AND L.CMS_LIMIT_STATUS <> 'DELETED'
					  AND M.UPDATE_STATUS_IND <> 'D'
					  AND S.STATUS <> 'DELETED'
			          AND M.CHARGE_ID = CM.CHARGE_ID 
					  AND C.CHARGE_DETAIL_ID = CM.CHARGE_DETAIL_ID   -- must have charge details
					  AND C.STATUS = 'ACTIVE'  
					  AND CM.STATUS = 'ACTIVE'  
					  AND CM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID  
					  AND S.CMV IS NOT NULL AND S.CMV <> 0   -- must perform valuation first
                      AND ( S.SECURITY_SUB_TYPE_ID LIKE 'PT%' OR S.SECURITY_SUB_TYPE_ID LIKE 'AB%' )  -- APPLY TO PROPERTY AND ASSET BASED ONLY
                      AND C.CHARGE_TYPE IS NOT NULL 					  
				GROUP BY CM.CMS_COLLATERAL_ID HAVING COUNT(*) > 1 
				) 
 			AND L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
			AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID	
			AND L.lmt_type_value = 'OUTER'
			AND L.CMS_LIMIT_STATUS <> 'DELETED'
			AND M.UPDATE_STATUS_IND <> 'D'
			AND S.STATUS <> 'DELETED'
			AND L.CMS_LIMIT_PROFILE_ID = P.CMS_LSP_LMT_PROFILE_ID
			AND P.CMS_BCA_STATUS  <> 'DELETED'
            AND M.CHARGE_ID = CM.CHARGE_ID 
			AND C.CHARGE_DETAIL_ID = CM.CHARGE_DETAIL_ID   -- must have charge details
			AND C.STATUS = 'ACTIVE'  
			AND CM.STATUS = 'ACTIVE'  
			AND CM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID  
			AND S.CMV IS NOT NULL AND S.CMV <> 0
			AND L.CMS_OUTSTANDING_AMT IS NOT NULL 
            AND ( S.SECURITY_SUB_TYPE_ID LIKE 'PT%' OR S.SECURITY_SUB_TYPE_ID LIKE 'AB%' )  -- APPLY TO PROPERTY AND ASSET BASED ONLY
			ORDER BY COL_ID, SECURITY_RANK

	DO 	
		
		IF main_cnt = 1 
		THEN
			--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 101);
		END IF;
		
		set main_cnt = main_cnt + 1;
		
		IF PREV_COL_ID IS NOT NULL AND PREV_COL_ID <> cur0.COL_ID
		THEN
	      	SET IS_FIRST = 1;  	
			SET IS_PREV_SPECIFIC = 0;  		
							
		END IF ;
		
		IF IS_FIRST = 1 THEN
			SET REMAIN_OMV = cur0.OMV;
			SET REMAIN_FSV = cur0.FSV;
			SET PREV_CHARGE_DTL_ID = NULL;
		END IF;
		
		SET TOTAL_LMT_OUTSTANDING = (select  dec( sum( inner_l.CMS_OUTSTANDING_AMT ), 20, 2) 
				from SCI_LSP_APPR_LMTS inner_l, CMS_LIMIT_SECURITY_MAP inner_M, CMS_LIMIT_CHARGE_MAP inner_cm, CMS_CHARGE_DETAIL inner_C 
				where  
				inner_CM.CMS_LSP_APPR_LMTS_ID = inner_L.CMS_LSP_APPR_LMTS_ID
				AND inner_C.CHARGE_DETAIL_ID = inner_CM.CHARGE_DETAIL_ID 
				AND inner_M.CHARGE_ID = inner_CM.CHARGE_ID 
				and inner_cm.CHARGE_DETAIL_ID = cur0.CHARGE_DTL_ID
				AND inner_L.lmt_type_value = 'OUTER'
				AND inner_L.CMS_LIMIT_STATUS <> 'DELETED'
				AND inner_M.UPDATE_STATUS_IND <> 'D'
				AND inner_C.STATUS = 'ACTIVE'  
				AND inner_CM.STATUS = 'ACTIVE');
				
		IF TOTAL_LMT_OUTSTANDING <> 0 THEN
			SET APPORTIONMENT_EXP = (round( dec(cur0.CMS_OUTSTANDING_AMT,20,2)/ TOTAL_LMT_OUTSTANDING , 16) );
		ELSE
			SET APPORTIONMENT_EXP = 0;
		END IF;
			
		IF IS_PREV_SPECIFIC = 0 THEN
		
			IF PREV_CHARGE_DTL_ID IS NOT NULL AND PREV_CHARGE_DTL_ID <> cur0.CHARGE_DTL_ID
			THEN 
							
				SET REMAIN_OMV = REMAIN_OMV - PREV_CHARGE_AMT;
			
				IF REMAIN_OMV < 0 THEN
					SET REMAIN_OMV = 0;
				END IF;
			END IF;
					
			IF REMAIN_OMV > cur0.CHARGE_AMT THEN
					  
				UPDATE SCI_LSP_APPR_LMTS SET 
						CMS_ACTUAL_SEC_COVERAGE_AMT = COALESCE( CMS_ACTUAL_SEC_COVERAGE_AMT, 0 ) +  ( APPORTIONMENT_EXP * dec(cur0.CHARGE_AMT, 20, 2) ), 
						CMS_OMV_SEC_COVERAGE_AMT = COALESCE( CMS_OMV_SEC_COVERAGE_AMT, 0 ) + ( APPORTIONMENT_EXP * dec(cur0.CHARGE_AMT, 20, 2) )
						--CMS_FSV_SEC_COVERAGE_AMT = TOTAL_FSV_ALLOC
						WHERE CMS_LSP_APPR_LMTS_ID = cur0.LMT_ID;
				
				UPDATE CMS_LIMIT_SECURITY_MAP SET CMS_SEC_ALLOCATED_AMT = COALESCE( CMS_SEC_ALLOCATED_AMT, 0 ) + ( APPORTIONMENT_EXP * dec(cur0.CHARGE_AMT, 20, 2) )
					WHERE CHARGE_ID = cur0.CHARGE_ID;
				
								
			ELSE
							
					UPDATE SCI_LSP_APPR_LMTS SET 
							CMS_ACTUAL_SEC_COVERAGE_AMT = COALESCE( CMS_ACTUAL_SEC_COVERAGE_AMT, 0 ) + ( APPORTIONMENT_EXP * dec( REMAIN_OMV, 20, 2 ) ), 
							CMS_OMV_SEC_COVERAGE_AMT = COALESCE( CMS_OMV_SEC_COVERAGE_AMT, 0 ) + ( APPORTIONMENT_EXP * dec( REMAIN_OMV, 20, 2 ) )
							--CMS_FSV_SEC_COVERAGE_AMT = REMAIN_FSV
							WHERE CMS_LSP_APPR_LMTS_ID = cur0.LMT_ID;
					
					UPDATE CMS_LIMIT_SECURITY_MAP SET CMS_SEC_ALLOCATED_AMT = COALESCE( CMS_SEC_ALLOCATED_AMT, 0 ) + ( APPORTIONMENT_EXP * dec( REMAIN_OMV, 20, 2 ) )
						WHERE CHARGE_ID = cur0.CHARGE_ID;
				
					
			END IF;
			
			IF PREV_CHARGE_DTL_ID IS NOT NULL AND PREV_CHARGE_DTL_ID <> cur0.CHARGE_DTL_ID
			THEN 
							
				SET REMAIN_FSV = REMAIN_FSV - PREV_CHARGE_AMT;
			
				IF REMAIN_FSV < 0 THEN
					SET REMAIN_FSV = 0;
				END IF;
			END IF;
			
			IF REMAIN_FSV > cur0.CHARGE_AMT THEN
					  
				UPDATE SCI_LSP_APPR_LMTS SET 
						--CMS_ACTUAL_SEC_COVERAGE_AMT = cur0.CHARGE_AMT, 
						--CMS_OMV_SEC_COVERAGE_AMT = cur0.CHARGE_AMT
						CMS_FSV_SEC_COVERAGE_AMT = COALESCE( CMS_FSV_SEC_COVERAGE_AMT, 0 ) + ( APPORTIONMENT_EXP * dec( cur0.CHARGE_AMT, 20, 2 ) ) 
						WHERE CMS_LSP_APPR_LMTS_ID = cur0.LMT_ID;
												
				
			ELSE
							
					UPDATE SCI_LSP_APPR_LMTS SET 
							--CMS_ACTUAL_SEC_COVERAGE_AMT = REMAIN_OMV, 
							--CMS_OMV_SEC_COVERAGE_AMT = REMAIN_OMV
							CMS_FSV_SEC_COVERAGE_AMT = COALESCE( CMS_FSV_SEC_COVERAGE_AMT, 0 ) + ( APPORTIONMENT_EXP * dec( REMAIN_FSV, 20, 2 ) )
							WHERE CMS_LSP_APPR_LMTS_ID = cur0.LMT_ID;
										
					
			END IF;						
			
		END IF; 	
		
		IF PREV_COL_ID IS NOT NULL AND PREV_COL_ID <> cur0.COL_ID
		THEN      			
			INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID,ALLOC_TYPE) VALUES(PREV_COL_ID,'1');	
		END IF;	
		
		SET PREV_CUST_ID = cur0.CUST_ID;  
		SET PREV_COL_ID = cur0.COL_ID;  
		SET PREV_CHARGE_DTL_ID = cur0.CHARGE_DTL_ID;  
		SET PREV_CHARGE_AMT = cur0.CHARGE_AMT;  
		
		--IF IS_PREV_SPECIFIC = 1 OR cur0.CHARGE_TYPE = 'S' THEN 
		--	SET IS_PREV_SPECIFIC = 1;  
		--END IF;
		SET IS_FIRST = 0;  
										
										 
	END FOR;		
	
	IF PREV_COL_ID IS NOT NULL 
	THEN      			
		INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID,ALLOC_TYPE) VALUES(PREV_COL_ID,'1');	
	END IF;	
	
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 102);
	SET main_cnt = 1;
	
	
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 2);
	SET main_cnt = 1;
	-- Priority 2:  Multiple collateral and limit linkage with different customer			
	FOR cur2 AS		
		  
		  -- SELECT THOSE COLL SHARED AMONG DIFF CUSTOMER		  
		   SELECT M.CMS_COLLATERAL_ID COL_ID, P.CMS_CUSTOMER_ID CUST_ID FROM 
				SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, SCI_LSP_LMT_PROFILE P
				WHERE
					L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
					AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
					AND L.lmt_type_value = 'OUTER'
					AND L.CMS_LIMIT_STATUS <> 'DELETED'
					AND M.UPDATE_STATUS_IND <> 'D'
					AND S.STATUS <> 'DELETED'
					AND L.CMS_LIMIT_PROFILE_ID = P.CMS_LSP_LMT_PROFILE_ID
					AND P.CMS_BCA_STATUS  <> 'DELETED'
					AND M.CMS_COLLATERAL_ID IN (
							SELECT M.CMS_COLLATERAL_ID FROM 
									  SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, CMS_LIMIT_CHARGE_MAP CM, CMS_CHARGE_DETAIL C
									  WHERE 
									  L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
							          AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
									  AND L.lmt_type_value = 'OUTER'
									  AND L.CMS_LIMIT_STATUS <> 'DELETED'
									  AND M.UPDATE_STATUS_IND <> 'D'
									  AND S.STATUS <> 'DELETED'									 
									  --AND CM.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID 
									  AND M.CHARGE_ID = CM.CHARGE_ID 
                                      AND C.CHARGE_DETAIL_ID = CM.CHARGE_DETAIL_ID  -- must have charge details
                                      AND C.STATUS = 'ACTIVE'  
                                      AND CM.STATUS = 'ACTIVE'  
                                      AND CM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID  
							          AND S.CMV IS NOT NULL AND S.CMV <> 0  -- must perform valuation first
									  AND S.SECURITY_SUB_TYPE_ID <> 'GT408'  -- filter out individual guarantee subtype
							GROUP BY M.CMS_COLLATERAL_ID HAVING COUNT(*) > 1 )			
				    --AND M.CMS_COLLATERAL_ID IN ( 20080623000113073, 20080623000113443 )
				    --AND L.LMT_ID IN ( SELECT LMT_ID FROM CMS_LIMIT_SEC_ALLOC )					
				GROUP BY M.CMS_COLLATERAL_ID, P.CMS_CUSTOMER_ID HAVING COUNT(*) = 1 


	DO 	
		
		IF main_cnt = 1 
		THEN
			--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 201);
		END IF;
		
		set main_cnt = main_cnt + 1;
		
		-- CHECK WHETHER THIS COLLATERAL BEEN PROCESS BEFORE
		set v_tmp_cnt = (SELECT COUNT(1) FROM CMS_PROCESS_COL_ALLOC WHERE COLL_ID = cur2.COL_ID); 
	  		
		IF v_tmp_cnt = 0 THEN	     			
		
			-- GET ALL FACILITY AND SEC (INCLUDING SHARED)  FOR THE COLLATERAL 					
			CALL GET_SHARED_COLL( cur2.COL_ID, main_cnt );				
	
			-- COMPUTE THE COL ALLOCATION
			CALL COMPUTE_SHARED_COLL();
			
			CALL PERSIST_COL_ALLOCATION;
			
		    INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID,ALLOC_TYPE) VALUES(cur2.COL_ID,'2');	
			
	    END IF;
								 
	END FOR;			
	
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 3);
	SET main_cnt = 1;
	-- Priority 3:  MULTIPLE collateral and limit linkage with same customer		
	FOR cur3 AS
		 SELECT M.CMS_COLLATERAL_ID COL_ID, p.CMS_CUSTOMER_ID cust_id FROM 
				SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, sci_lsp_lmt_profile p
				WHERE
					L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
					AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
					AND L.lmt_type_value = 'OUTER'
					AND L.CMS_LIMIT_STATUS <> 'DELETED'
					AND M.UPDATE_STATUS_IND <> 'D'
					AND S.STATUS <> 'DELETED'
					AND l.CMS_LIMIT_PROFILE_ID = p.CMS_LSP_LMT_PROFILE_ID
					AND p.CMS_BCA_STATUS  <> 'DELETED'
					AND M.CMS_COLLATERAL_ID IN (
							SELECT M.CMS_COLLATERAL_ID FROM 
									  SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, CMS_LIMIT_CHARGE_MAP CM, CMS_CHARGE_DETAIL C
									  WHERE 
									  L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
							          AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
									  AND L.lmt_type_value = 'OUTER'
									  AND L.CMS_LIMIT_STATUS <> 'DELETED'
									  AND M.UPDATE_STATUS_IND <> 'D'
									  AND S.STATUS <> 'DELETED'									 
									  --AND CM.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID 
									  AND M.CHARGE_ID = CM.CHARGE_ID 
                                      AND C.CHARGE_DETAIL_ID = CM.CHARGE_DETAIL_ID   -- must have charge details
                                      AND C.STATUS = 'ACTIVE'  
                                      AND CM.STATUS = 'ACTIVE'  
                                      AND CM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID  
							          AND S.CMV IS NOT NULL AND S.CMV <> 0  -- must perform valuation first
									  AND S.SECURITY_SUB_TYPE_ID <> 'GT408'  -- filter out individual guarantee subtype
							GROUP BY M.CMS_COLLATERAL_ID HAVING COUNT(*) > 1 )			
				--AND M.CMS_COLLATERAL_ID IN ( 20080623000113073, 20080623000113443 )
				--AND L.LMT_ID IN ( SELECT LMT_ID FROM CMS_LIMIT_SEC_ALLOC )
				--AND L.CMS_LSP_APPR_LMTS_ID=20081220000035279
				GROUP BY M.CMS_COLLATERAL_ID, p.CMS_CUSTOMER_ID HAVING COUNT(*) > 1 

	DO 	
		IF main_cnt = 1 
		THEN
			--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 301);
		END IF;
		
		set main_cnt = main_cnt + 1;
		-- CHECK WHETHER THIS COLLATERAL BEEN PROCESS BEFORE		
		set v_tmp_cnt = (SELECT COUNT(1) FROM CMS_PROCESS_COL_ALLOC WHERE COLL_ID = cur3.COL_ID); 
				
	    IF v_tmp_cnt = 0 THEN
	      		  
			-- GET ALL FACILITY AND SEC (INCLUDING SHARED)  FOR THE COLLATERAL  
			CALL GET_SHARED_COLL( cur3.COL_ID, main_cnt );
			
			-- COMPUTE THE COL ALLOCATION
			CALL COMPUTE_SHARED_COLL();
			
			CALL PERSIST_COL_ALLOCATION;
			
		    INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID,ALLOC_TYPE) VALUES(cur3.COL_ID,'3');	
	    END IF;			
		 
	END FOR;	
	
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 4);
	
	SET main_cnt = 1;
	-- Priority 4:  MULTIPLE collateral to single limit linkage with same customer		
	FOR cur4 AS
		 SELECT M.CMS_COLLATERAL_ID COL_ID, p.CMS_CUSTOMER_ID cust_id FROM 
				SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, sci_lsp_lmt_profile p
				WHERE
					L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
					AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
					AND L.lmt_type_value = 'OUTER'
					AND L.CMS_LIMIT_STATUS <> 'DELETED'
					AND M.UPDATE_STATUS_IND <> 'D'
					AND S.STATUS <> 'DELETED'
					AND l.CMS_LIMIT_PROFILE_ID = p.CMS_LSP_LMT_PROFILE_ID
					AND p.CMS_BCA_STATUS  <> 'DELETED'
					AND L.CMS_LSP_APPR_LMTS_ID IN (
							SELECT L.CMS_LSP_APPR_LMTS_ID FROM 
									  SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, CMS_LIMIT_CHARGE_MAP CM, CMS_CHARGE_DETAIL C
									  WHERE 
									  L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
							          AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
									  AND L.lmt_type_value = 'OUTER'
									  AND L.CMS_LIMIT_STATUS <> 'DELETED'
									  AND M.UPDATE_STATUS_IND <> 'D'
									  AND S.STATUS <> 'DELETED'									 
									  --AND CM.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID 
									  AND M.CHARGE_ID = CM.CHARGE_ID 
                                      AND C.CHARGE_DETAIL_ID = CM.CHARGE_DETAIL_ID   -- must have charge details
                                      AND C.STATUS = 'ACTIVE'  
                                      AND CM.STATUS = 'ACTIVE'  
                                      AND CM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID  
							          AND S.CMV IS NOT NULL AND S.CMV <> 0  -- must perform valuation first
									  AND S.SECURITY_SUB_TYPE_ID <> 'GT408'  -- filter out individual guarantee subtype
							GROUP BY L.CMS_LSP_APPR_LMTS_ID HAVING COUNT(*) > 1 )			
				--AND M.CMS_COLLATERAL_ID IN ( 20081222000149009 )
				--AND L.LMT_ID IN ( SELECT LMT_ID FROM CMS_LIMIT_SEC_ALLOC )
				--AND L.CMS_LSP_APPR_LMTS_ID=20081220000035279
 

	DO 	
		IF main_cnt = 1 
		THEN
			--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 401);
		END IF;
		
		set main_cnt = main_cnt + 1;
		-- CHECK WHETHER THIS COLLATERAL BEEN PROCESS BEFORE		
		set v_tmp_cnt = (SELECT COUNT(1) FROM CMS_PROCESS_COL_ALLOC WHERE COLL_ID = cur4.COL_ID); 
				
	    IF v_tmp_cnt = 0 THEN
	      		  
			-- GET ALL FACILITY AND SEC (INCLUDING SHARED)  FOR THE COLLATERAL  
			CALL GET_SHARED_COLL( cur4.COL_ID, main_cnt );
			
			-- COMPUTE THE COL ALLOCATION
			CALL COMPUTE_SHARED_COLL();
			
			CALL PERSIST_COL_ALLOCATION;
			
		    INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID,ALLOC_TYPE) VALUES(cur4.COL_ID,'4');	
	    END IF;			
		 
	END FOR;	
	
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 5);
	
	
	SET main_cnt = 1;
	-- Priority 5:   Single collateral and limit linkage			
	FOR cur5 AS
	
		SELECT M.CMS_COLLATERAL_ID COL_ID, L.CMS_LSP_APPR_LMTS_ID LMT_ID, M.CHARGE_ID CHARGE_ID, P.CMS_CUSTOMER_ID CUST_ID,
			CONVERT_AMT( S.CMV, S.CMV_CURRENCY, 'MYR' ) CMV, 
			CONVERT_AMT( S.FSV, S.FSV_CURRENCY, 'MYR' ) FSV, 
			CONVERT_AMT( S.NET_REALIZABLE_VALUE, S.SCI_SECURITY_CURRENCY, 'MYR' ) RV,			
			CONVERT_AMT( S.RESERVE_PRICE, S.SCI_SECURITY_CURRENCY, 'MYR' ) RP			
			--( 
			--	CASE WHEN 
			--	SECURITY_SUB_TYPE_ID LIKE 'PT%' OR 
			--	SECURITY_SUB_TYPE_ID LIKE 'AB%' OR 
			--	SECURITY_SUB_TYPE_ID LIKE 'OT%'  
			--	THEN ( 
			--		SELECT CONVERT_AMT( V.RESERVE_PRICE , V.VALUATION_CURRENCY, 'MYR' ) 
			--		FROM CMS_VALUATION V 
			--		WHERE V.CMS_COLLATERAL_ID = s.CMS_COLLATERAL_ID 
			--				AND V.SOURCE_TYPE = 'M' 
			--				AND V.RESERVE_PRICE IS NOT NULL AND V.RESERVE_PRICE <> 0 
			--		ORDER BY V.VALUATION_DATE DESC, V.VALUATION_ID DESC 
			--		FETCH FIRST 1 ROWS ONLY 
			--	 ) 
			--	ELSE 0 
			--	END 			
			--) RP --,
			--( 
			--	SELECT X.ACCT_DELQ_IND FROM SCI_LSP_LMTS_XREF_MAP XM, SCI_LSP_SYS_XREF X 
			--	WHERE 
			--	X.CMS_LSP_SYS_XREF_ID = XM.CMS_LSP_SYS_XREF_ID
			--			AND XM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID 
			--			AND XM.CMS_STATUS = 'ACTIVE'
			--	FETCH FIRST 1 ROWS ONLY 							
			--) npl_status
			FROM SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, SCI_LSP_LMT_PROFILE p 
			WHERE ( S.CMS_COLLATERAL_ID ) IN (
				SELECT M.CMS_COLLATERAL_ID FROM 
					  SCI_LSP_APPR_LMTS L, CMS_LIMIT_SECURITY_MAP M, CMS_SECURITY S, CMS_LIMIT_CHARGE_MAP CM, CMS_CHARGE_DETAIL C
					  WHERE 
					  L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
			          AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID
					  AND L.LMT_TYPE_VALUE = 'OUTER'
					  AND L.CMS_LIMIT_STATUS <> 'DELETED'
					  AND M.UPDATE_STATUS_IND <> 'D'
					  AND S.STATUS <> 'DELETED'
			          AND M.CHARGE_ID = CM.CHARGE_ID 
					  AND C.CHARGE_DETAIL_ID = CM.CHARGE_DETAIL_ID   -- must have charge details
					  AND C.STATUS = 'ACTIVE'  
					  AND CM.STATUS = 'ACTIVE'  
					  AND CM.CMS_LSP_APPR_LMTS_ID = L.CMS_LSP_APPR_LMTS_ID  
					  AND S.CMV IS NOT NULL AND S.CMV <> 0   -- must perform valuation first
					  AND S.SECURITY_SUB_TYPE_ID <> 'GT408'  -- filter out individual guarantee subtype
				GROUP BY M.CMS_COLLATERAL_ID HAVING COUNT(*) = 1 )
 			AND L.CMS_LSP_APPR_LMTS_ID = M.CMS_LSP_APPR_LMTS_ID
			AND M.CMS_COLLATERAL_ID = S.CMS_COLLATERAL_ID	
			AND L.lmt_type_value = 'OUTER'
			AND L.CMS_LIMIT_STATUS <> 'DELETED'
			AND M.UPDATE_STATUS_IND <> 'D'
			AND S.STATUS <> 'DELETED'
			AND L.CMS_LIMIT_PROFILE_ID = P.CMS_LSP_LMT_PROFILE_ID
			AND P.CMS_BCA_STATUS  <> 'DELETED'
			AND S.SECURITY_SUB_TYPE_ID <> 'GT408'  -- filter out individual guarantee subtype
			--AND M.CMS_COLLATERAL_ID IN ( 20080623000113073, 20080623000113443 )
			--AND L.LMT_ID IN ( SELECT LMT_ID FROM CMS_LIMIT_SEC_ALLOC )
		
	DO 	
		IF main_cnt = 1 
		THEN
			--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 501);
		END IF;
		
		set main_cnt = main_cnt + 1;
		-- CHECK WHETHER THIS COLLATERAL BEEN PROCESS BEFORE
		set v_tmp_cnt = (SELECT COUNT(1) FROM CMS_PROCESS_COL_ALLOC WHERE COLL_ID = cur5.COL_ID); 
	   		
	    IF v_tmp_cnt = 0 THEN	      
		  
			-- performing loan
			SET is_npl_ind = (SELECT COUNT(1) FROM SESSION.NPL_ACCOUNT WHERE LIMIT_ID = cur5.LMT_ID); 
	  															
			IF is_npl_ind is NULL OR is_npl_ind = 0 THEN	 
			--IF cur5.npl_status IS NULL OR cur5.npl_status = 'N' THEN
				UPDATE SCI_LSP_APPR_LMTS L SET ( CMS_ACTUAL_SEC_COVERAGE_AMT, CMS_OMV_SEC_COVERAGE_AMT, CMS_FSV_SEC_COVERAGE_AMT ) = 
					( COALESCE( CMS_ACTUAL_SEC_COVERAGE_AMT, 0 ) + cur5.CMV, 
					COALESCE( CMS_OMV_SEC_COVERAGE_AMT, 0 ) + cur5.CMV, 
					COALESCE( CMS_FSV_SEC_COVERAGE_AMT, 0 ) + cur5.FSV )
				WHERE L.CMS_LSP_APPR_LMTS_ID = cur5.LMT_ID;
				
				UPDATE CMS_LIMIT_SECURITY_MAP M SET ( CMS_SEC_ALLOCATED_AMT ) = ( COALESCE( CMS_SEC_ALLOCATED_AMT, 0 ) + cur5.CMV )
				WHERE M.CHARGE_ID = cur5.CHARGE_ID;			
			
			ELSE					
			-- non performing loan
			
			    SET LOWEST_SEC_VAL = getLowestAmt( cur5.FSV, cur5.RV, cur5.RP );   	   
		
				UPDATE SCI_LSP_APPR_LMTS L SET ( CMS_ACTUAL_SEC_COVERAGE_AMT, CMS_OMV_SEC_COVERAGE_AMT, CMS_FSV_SEC_COVERAGE_AMT ) = 
						( COALESCE( CMS_ACTUAL_SEC_COVERAGE_AMT, 0 ) + LOWEST_SEC_VAL, 
						COALESCE( CMS_OMV_SEC_COVERAGE_AMT, 0 ) + cur5.CMV, 
						COALESCE( CMS_FSV_SEC_COVERAGE_AMT, 0 ) + cur5.FSV )
				WHERE L.CMS_LSP_APPR_LMTS_ID = cur5.LMT_ID;
				
				UPDATE CMS_LIMIT_SECURITY_MAP M SET (CMS_SEC_ALLOCATED_AMT) = ( COALESCE( CMS_SEC_ALLOCATED_AMT, 0 ) + LOWEST_SEC_VAL )
				WHERE M.CHARGE_ID = cur5.CHARGE_ID;
			END IF;	

			INSERT INTO CMS_PROCESS_COL_ALLOC(COLL_ID,ALLOC_TYPE) VALUES(cur5.COL_ID,'5');	
			
		END IF; 
	END FOR;	
		
	--CALL SI_LOG_PROC_TIME('PROC_COLL_ALLOC_MAIN', 'ALOC', 0);
	--DELETE FROM CMS_PROCESS_COL_ALLOC;
			
	COMMIT;
	
END@
			

DROP PROCEDURE PROC_COLL_ALLOC_ALL@

CREATE PROCEDURE PROC_COLL_ALLOC_ALL
	LANGUAGE SQL
BEGIN 
	
	CALL PROC_CLEAR_PREV_ALLOC;
	CALL PROC_COLL_ALLOC_MAIN;
	
END@

